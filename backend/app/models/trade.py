"""Trade and signal models for Trading System v2.0"""

from enum import Enum
from datetime import datetime, date
from typing import Dict, List, Optional
from pydantic import BaseModel, Field
import uuid


class StructureType(str, Enum):
    """Option structure types."""
    IRON_CONDOR = "IRON_CONDOR"
    JADE_LIZARD = "JADE_LIZARD"
    RISK_REVERSAL = "RISK_REVERSAL"
    BUTTERFLY = "BUTTERFLY"
    IRON_BUTTERFLY = "IRON_BUTTERFLY"
    BROKEN_WING_BUTTERFLY = "BROKEN_WING_BUTTERFLY"
    DEBIT_SPREAD = "DEBIT_SPREAD"
    CREDIT_SPREAD = "CREDIT_SPREAD"
    CALENDAR_SPREAD = "CALENDAR_SPREAD"
    DIAGONAL_SPREAD = "DIAGONAL_SPREAD"
    INTRADAY_FADE = "INTRADAY_FADE"
    NAKED_STRANGLE = "NAKED_STRANGLE"
    STRADDLE = "STRADDLE"


class LegType(str, Enum):
    """Option leg types."""
    LONG_CALL = "LONG_CALL"
    SHORT_CALL = "SHORT_CALL"
    LONG_PUT = "LONG_PUT"
    SHORT_PUT = "SHORT_PUT"
    LONG_FUTURE = "LONG_FUTURE"
    SHORT_FUTURE = "SHORT_FUTURE"


class TradeLeg(BaseModel):
    """Individual leg of a multi-leg trade."""
    leg_id: str = Field(default_factory=lambda: str(uuid.uuid4())[:8])
    leg_type: LegType = Field(..., description="Type of leg")
    tradingsymbol: str = Field(..., description="Trading symbol")
    instrument_token: int = Field(..., description="Instrument token")
    exchange: str = Field("NFO", description="Exchange")
    
    strike: Optional[float] = Field(None, description="Strike price for options")
    expiry: Optional[date] = Field(None, description="Expiry date")
    option_type: Optional[str] = Field(None, description="CE or PE")
    
    quantity: int = Field(..., description="Quantity (lot size)")
    entry_price: float = Field(..., description="Entry price")
    current_price: Optional[float] = Field(None, description="Current market price")
    
    # Greeks
    delta: float = Field(0.0, description="Delta")
    gamma: float = Field(0.0, description="Gamma")
    theta: float = Field(0.0, description="Theta")
    vega: float = Field(0.0, description="Vega")
    
    @property
    def is_long(self) -> bool:
        return self.leg_type in [LegType.LONG_CALL, LegType.LONG_PUT, LegType.LONG_FUTURE]
    
    @property
    def is_short(self) -> bool:
        return not self.is_long
    
    @property
    def pnl(self) -> float:
        if self.current_price is None:
            return 0.0
        diff = self.current_price - self.entry_price
        return diff * self.quantity if self.is_long else -diff * self.quantity


class TradeProposal(BaseModel):
    """
    Trade proposal generated by Strategist, pending Treasury approval.
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Structure info
    structure: StructureType = Field(..., description="Trade structure type")
    instrument: str = Field(..., description="Underlying instrument")
    instrument_token: int = Field(..., description="Underlying token")
    
    # Legs
    legs: List[TradeLeg] = Field(..., description="Trade legs")
    
    # Entry details
    entry_price: float = Field(..., description="Net entry price/credit")
    is_credit: bool = Field(True, description="True if credit trade")
    
    # Risk/reward
    max_profit: float = Field(..., description="Maximum profit")
    max_loss: float = Field(..., description="Maximum loss")
    target_pnl: float = Field(..., description="Profit target")
    stop_loss: float = Field(..., description="Stop loss level")
    risk_reward_ratio: float = Field(..., description="Risk/reward ratio")
    
    # Margin and sizing
    required_margin: float = Field(..., description="Required margin")
    position_size_pct: float = Field(..., description="Position size as % of equity")
    
    # Greeks (aggregate)
    greeks: Dict[str, float] = Field(
        default_factory=lambda: {"delta": 0, "gamma": 0, "theta": 0, "vega": 0}
    )
    
    # Expiry
    expiry: date = Field(..., description="Expiry date")
    days_to_expiry: int = Field(..., description="Days to expiry")
    
    # Dynamic Exit Targeting (Section 4 of rulebook)
    exit_target_low: float = Field(..., description="Lower bound for profit target")
    exit_target_high: float = Field(..., description="Upper bound for profit target")
    exit_margin_type: str = Field("margin", description="Type: 'margin' or 'percentage'")
    
    # Trailing Profit Settings (Section 11 of rulebook)
    enable_trailing: bool = Field(True, description="Enable trailing profit logic")
    trailing_profit_threshold: float = Field(0.5, description="Start trailing at 50% of target")
    trailing_mode: str = Field("none", description="'atr' for directional, 'bbw' for short-vol")
    
    # Context
    regime_at_entry: str = Field(..., description="Regime when signal generated")
    entry_reason: str = Field(..., description="Reason for entry")
    
    # Flags
    is_intraday: bool = Field(False, description="True if intraday trade")
    
    def calculate_greeks(self) -> Dict[str, float]:
        """Calculate aggregate Greeks from legs."""
        greeks = {"delta": 0, "gamma": 0, "theta": 0, "vega": 0}
        for leg in self.legs:
            multiplier = 1 if leg.is_long else -1
            greeks["delta"] += leg.delta * multiplier
            greeks["gamma"] += leg.gamma * multiplier
            greeks["theta"] += leg.theta * multiplier
            greeks["vega"] += leg.vega * multiplier
        self.greeks = greeks
        return greeks
    
    def get_dynamic_target(self, entry_margin: float) -> tuple:
        """Calculate dynamic exit target based on entry margin."""
        if self.exit_margin_type == "margin":
            low = entry_margin * self.exit_target_low
            high = entry_margin * self.exit_target_high
        else:
            low = self.max_profit * self.exit_target_low
            high = self.max_profit * self.exit_target_high
        return low, high


class TradeSignal(BaseModel):
    """
    Approved trade signal ready for execution.
    Created after Treasury approval.
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    proposal_id: str = Field(..., description="Original proposal ID")
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Approved details
    structure: StructureType
    instrument: str
    legs: List[TradeLeg]
    
    # Adjusted sizing (may differ from proposal after Treasury review)
    approved_margin: float
    approved_size_pct: float
    drawdown_multiplier: float = Field(1.0, description="Size multiplier based on drawdown")
    
    # Execution parameters
    order_type: str = Field("LIMIT", description="Order type")
    validity: str = Field("DAY", description="Order validity")
    product: str = Field("NRML", description="Product type")
    
    # Risk parameters
    target_pnl: float
    stop_loss: float
    exit_dte: int = Field(5, description="Mandatory exit DTE for short-vol")
    
    # Approval info
    approved_by: str = Field("TREASURY", description="Approving agent")
    approval_reason: str = Field("", description="Approval notes")
